# Merkle Patricia Forestry

Haskell library to interact with [Merkle Patricia Forestry](https://github.com/aiken-lang/merkle-patricia-forestry?tab=readme-ov-file) data structure.

This library is meant to be imported qualified. Sample operation is below and see `Crypto.Hash.MerklePatriciaForestry` module for complete client side API.

```haskell
import Crypto.Hash.MerklePatriciaForestry qualified as MPF


-- Building Merkle Patricia Forestry.
mpf = MPF.empty 
     & MPF.insert (keyFromString "hail") (valueFromString "haskell")
     -- `Key`, `Value` have `IsString` instances.
     & MPF.insert "🙅‍♂️" "JS"
     -- Would update in case of duplicate key.
     & MPF.insert "hail" "🐼"
     -- Deletion for non-existent key, returns the original trie.
     & MPF.delete "does-not-exist"

-- Member lookup.
hailValue = MPF.lookup "hail" mpf

-- Generates proof for verifying "hail" to be a member of our trie.
hailProof = MPF.generateProof "hail" mpf

```
## Representing proof on-chain

To interact with on-chain validators that utilize Merkle Patricia Forestry, one can define following types for proof inside their off-chain code and use [`plutus-tx`](https://github.com/IntersectMBO/plutus) to generate UPLC data conversion related instances.

```haskell
-- | `Neighbor` corresponding to on-chain `Neighbor` type, see it for more details.
data Neighbor = Neighbor
  { neighborNibble :: Integer
  , neighborPrefix :: PlutusTx.BuiltinByteString
  , neighborRoot :: PlutusTx.BuiltinByteString
  }
  deriving stock (Show)

$(PlutusTx.unstableMakeIsData ''Neighbor)

-- | `ProofStep` corresponding to on-chain `ProofStep` type, see it for more details.
data ProofStep
  = Branch {branchSkip :: Integer, branchNeighbors :: PlutusTx.BuiltinByteString}
  | Fork {forkSkip :: Integer, forkNeighbor :: Neighbor}
  | Leaf {leafSkip :: Integer, leafKey :: PlutusTx.BuiltinByteString, leafValue :: PlutusTx.BuiltinByteString}
  deriving stock (Show)

$(PlutusTx.unstableMakeIsData ''ProofStep)

-- | Actual proof type used in on-chain validator.
type Proof = [ProofStep]

proofFromMPF :: MPF.Proof -> Proof
proofFromMPF (MPF.proofSteps -> steps) = map proofStepFromMPF steps

proofStepFromMPF :: MPF.ProofStep -> ProofStep
proofStepFromMPF (MPF.ProofStepBranch psbPrefixLength psbMerkleProof) =
  Branch
    (fromIntegral psbPrefixLength)
    (PlutusTx.toBuiltin $ mconcat psbMerkleProof)
proofStepFromMPF (MPF.ProofStepLeaf{..}) =
  Leaf
    (fromIntegral pslPrefixLength)
    (PlutusTx.toBuiltin $ MPF.hexDigitsToByteStringSupportsOdd pslNeighbourKeyPath)
    (PlutusTx.toBuiltin pslNeighbourValueDigest)
proofStepFromMPF (MPF.ProofStepFork{..}) =
  Fork
    (fromIntegral psfPrefixLength)
    ( Neighbor
        { neighborNibble = fromIntegral $ MPF.unHexDigit psfNeighbourIx
        , neighborPrefix = PlutusTx.toBuiltin $ MPF.hexDigitsToByteStringSupportsOdd psfNeighbourPrefix
        , neighborRoot = PlutusTx.toBuiltin psfNeighbourMerkleRoot
        }
    )
```

In above code, `proofFromMPF` converts proof generated by this library to the off-chain type of proof as defined in above code.

Additionally, we provide `proofToAiken` to generate Aiken code for proof. This is useful for debugging/testing inside Aiken code. 

## Credits

* https://github.com/aiken-lang/merkle-patricia-forestry?tab=readme-ov-file.
* https://github.com/blinklabs-io/merkle-patricia-forestry.